package com.lianlian.osc.gateway.client.http;

import com.alibaba.fastjson.JSONObject;
import com.lianlian.ew.open.request.AttachmentUploadReq;
import com.lianlian.ew.open.response.FileContent;
import com.lianlian.ew.open.response.ResTypeReference;
import com.lianlian.ew.open.response.RichOpenRes;
import com.lianlian.osc.gateway.client.ApiException;
import com.lianlian.osc.gateway.client.response.ApiResult;
import com.lianlian.osc.gateway.client.util.GatewayConstants;
import com.lianlian.osc.gateway.client.request.ApiMenthod;
import com.lianlian.osc.gateway.client.util.CipherException;
import com.lianlian.osc.gateway.client.util.RSA;
import org.apache.http.*;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.entity.mime.HttpMultipartMode;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.entity.mime.content.FileBody;
import org.apache.http.entity.mime.content.StringBody;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Base64;

/**
 * Proxy implementation for Gateway clients.
 * Applications will generally use GatewayProxyFactory to create proxy clients.
 * <p>
 * GatewayProxy is a proxy class that handles the invocation of the Gateway API.
 * It is a dynamic proxy class that is generated by the GatewayProxyFactory.
 *
 * @author xujs002
 */
public class GatewayHttpInvoker {

    /**
     * close the http client and response
     *
     * @param response
     * @param httpclient
     */
    private static void close(CloseableHttpResponse response, CloseableHttpClient httpclient) {
        if (response != null) {
            try {
                response.close();
            } catch (Exception e) {

            }
        }
        if (httpclient != null) {
            try {
                httpclient.close();
            } catch (Exception e) {

            }
        }
    }

    public static String upload(String fullUri, String authorizationType, String developerId, String token, AttachmentUploadReq req) throws IOException {
        CloseableHttpClient httpclient = null;
        CloseableHttpResponse response = null;
        try {
            httpclient = HttpClients.createDefault();
            HttpPost httpMenthod = new HttpPost(fullUri);
            String realToken = Base64.getEncoder().encodeToString((developerId + ":" + token).getBytes());
            httpMenthod.setHeader(GatewayConstants.AUTHORIZATION, authorizationType + realToken);
            RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(200000).setSocketTimeout(200000).build();
            httpMenthod.setConfig(requestConfig);
            Path path = Paths.get(req.getAttachment().getPath());
            String contentType = null;
            contentType = Files.probeContentType(path);
            FileBody fileBody = new FileBody(req.getAttachment(), ContentType.create(contentType), req.getAttachment().getName());
            MultipartEntityBuilder multipartEntityBuilder = MultipartEntityBuilder.create().addPart("file", fileBody);
            multipartEntityBuilder.setMode(HttpMultipartMode.RFC6532);
            if (req.getExtensionInfo() != null) {
                StringBody comment = new StringBody(JSONObject.toJSONString(req.getExtensionInfo()), ContentType.APPLICATION_JSON);
                multipartEntityBuilder = multipartEntityBuilder.addPart("extension_info", comment);
            }
            HttpEntity reqEntity = multipartEntityBuilder.build();
            httpMenthod.setEntity(reqEntity);
            response = httpclient.execute(httpMenthod);
            //System.out.println(response.getStatusLine());
            HttpEntity resEntity = response.getEntity();
            String responseBody = EntityUtils.toString(response.getEntity());
            //System.out.println("responseBody:" + responseBody);
            return responseBody;
        } finally {
            close(response, httpclient);
        }
    }


    public static FileContent downLoad(String fullUri, String authorizationType, String developerId, String token) throws IOException {
        HttpEntityEnclosingRequestBase httpMenthod = new HttpGetWithBody(fullUri);
        HttpEntity httpEntity = new StringEntity("", ContentType.APPLICATION_JSON);
        httpMenthod.setEntity(httpEntity);
        String realToken = Base64.getEncoder().encodeToString((developerId + ":" + token).getBytes());
        httpMenthod.setHeader(GatewayConstants.AUTHORIZATION, authorizationType + realToken);
        String filename = null;
        CloseableHttpClient client = HttpClients.createDefault();
        byte[] responseBody = null;
        String responseStringBody = null;
        CloseableHttpResponse response = null;
        try {
            response = client.execute(httpMenthod);
            StatusLine statusLine = response.getStatusLine();
            HttpEntity entity = response.getEntity();
            if (statusLine.getStatusCode() == HttpStatus.SC_OK) {
                responseBody = EntityUtils.toByteArray(entity);
                filename = response.getFirstHeader("Content-Disposition").getValue().split(";")[1].split("=")[1].replaceAll("\"", "");
                return new FileContent(filename, responseBody);
            } else {
                responseStringBody = EntityUtils.toString(entity, "UTF-8");
                ApiResult apiErrorResult = ApiResult.error(responseStringBody);
                throw new ApiException(statusLine.getStatusCode(), statusLine.getReasonPhrase(), apiErrorResult.getCode(), apiErrorResult.getMessage());
            }
//            Header[] headers = response.getHeaders("Content-Disposition");
//            if (headers != null) {
//                for (Header header : headers) {
//                    HeaderElement[] elements = header.getElements();
//                    if (elements != null) {
//                        for (HeaderElement e : elements) {
//                            NameValuePair pair = e.getParameterByName("filename");
//                            filename = pair.getValue();
//                        }
//                    }
//                }
//            }
//            if (filename == null || filename.length() == 0) {
//                responseStringBody = EntityUtils.toString(entity, "UTF-8");
//            } else {
//                responseBody = EntityUtils.toByteArray(entity);
//            }
        } finally {
            close(response, client);
        }

    }


    public static String httpInvoke(String fullUri, String realUri, ApiMenthod apiMenthod, String body, String
            authorizationType, String token, String privateKey, boolean needSign, boolean needVerifyResponse, String lianlianPublicKey) throws IOException {

        HttpEntityEnclosingRequestBase httpMenthod = null;
        switch (apiMenthod) {
            case GET: {
                httpMenthod = new HttpGetWithBody(fullUri);
                break;
            }
            case POST: {
                httpMenthod = new HttpPost(fullUri);
                break;
            }
            case PUT:
                httpMenthod = new HttpPut(fullUri);
                break;
            case DELETE:
                httpMenthod = new HttpDeleteWithBody(fullUri);
                break;
            case PATCH:
                httpMenthod = new HttpPatchWithBody(fullUri);
                break;
        }
        if (httpMenthod == null) {
            throw new IllegalArgumentException("Unsupported HTTP Method");
        }

        RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(200000).setSocketTimeout(200000).build();
        httpMenthod.setConfig(requestConfig);

        HttpEntity httpEntity = new StringEntity(body, ContentType.APPLICATION_JSON);
        httpMenthod.setEntity(httpEntity);
        httpMenthod.setHeader(GatewayConstants.AUTHORIZATION, authorizationType + token);
        if (needSign) {
            httpMenthod.setHeader(GatewayConstants.SIGNATURE_HEADER, getSign(realUri, apiMenthod, body, privateKey));
        }
        CloseableHttpClient client = HttpClients.createDefault();
        String responseBody = null;

        CloseableHttpResponse response = client.execute(httpMenthod);
        StatusLine statusLine = response.getStatusLine();
        int statusCode = statusLine.getStatusCode();
        HttpEntity entity = response.getEntity();
        responseBody = EntityUtils.toString(entity, "UTF-8");
        if (statusCode != HttpStatus.SC_OK) {
            ApiResult apiErrorResult = ApiResult.error(responseBody);
            throw new ApiException(statusCode, statusLine.getReasonPhrase(), apiErrorResult.getCode(), apiErrorResult.getMessage());
        }
        if (needVerifyResponse) {
            String sign = response.getFirstHeader(GatewayConstants.SIGNATURE_HEADER).getValue();
            boolean isResponseVerified = verifyResponse(sign, responseBody, lianlianPublicKey);
            if (!isResponseVerified) {
                throw new ApiException(statusCode, statusLine.getReasonPhrase(), "response_verify_failed", "response verify failed");
            }
        }

        close(response, client);
        return responseBody;

    }


    private static boolean verifyResponse(String llpSignHeader, String responseBody, String lianlianPublicKey) {
        try {
            String[] arr = llpSignHeader.split(",");
            String responseEpoch = arr[0].substring("t=".length());
            String responseSign = arr[1].substring("v=".length());
            return RSA.verify(RSA.Mode.SHA256withRSA, responseEpoch + "&" + responseBody, responseSign, lianlianPublicKey);
        } catch (Exception e) {
            return false;
        }
    }


    /**
     * get sign to invoke LianLian Global API
     *
     * @param realUri
     * @param apiMenthod
     * @param requestBody
     * @param privateKey
     * @return
     */
    public static String getSign(String realUri, ApiMenthod apiMenthod, String requestBody, String privateKey) {
        String epoch = System.currentTimeMillis() / 1000 + "";
        StringBuilder sBuilder = new StringBuilder(apiMenthod.getMenthod());
        sBuilder
                .append(GatewayConstants.CONCAT_STR)
                .append(realUri)
                .append(GatewayConstants.CONCAT_STR)
                .append(epoch)
                .append(GatewayConstants.CONCAT_STR)
                .append(requestBody);
        try {
            String sign = RSA.sign(RSA.Mode.SHA256withRSA, sBuilder.toString(), privateKey);
            String signHeader = String.format("t=%s,v=%s", epoch, sign);
            return signHeader;
        } catch (CipherException e) {
            e.printStackTrace();
        }
        return sBuilder.toString();
    }

//
//    public static void main(String[] args) throws CipherException {
//        StringBuilder sBuilder = new StringBuilder("GET");
//        sBuilder.append("GET&/gateway/v1/ew-balances&1657261165&");
//        String privateKey = "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAI8Rz/Xxzkxvh/Ecd1eYjBWeWQoUuPOK42lprtw349S0LX0dL4KzKv89RdNHmhNnAwiGcWaRZQaeRtDpbOTi4Ywa1qHOlhjdIduLCaDPkUmh1x3mWApZElwMMZwIGmRDtPvMvw6FWZ+ev1tZp3XqGs4ojB5XDMCIAh0cQ3FhYou/AgMBAAECgYBvsVxFig2gpsHefna9MB7NEd45fIwXtipsNVGKIyf++ts4ffyFcRL0SQWmOJQU6ar4kN0fUgso65AlsNaOqoGiDGKvsb1d4p+1PJvRXog6hluL7aMO+DN0gepPMSmkIVHWf/LVwImHe49APMajG4dHVVKsqGNzkEZniZgbDMXWIQJBAONIK/JMpKi/8nAHwY9gVOqTLLcnFcdO3OA8z6K/Yrf8/SCeBBfIJ01UJfDYF0J9g5LdJu5Z2Aix3hn84f+f83sCQQChJaVzqwY/Unr8imXvBrNv4oWuzlfNiJeAgGk6lMzamrcSturosssXPoSqPd42rt6Q1HugauC2lR2QvNHsnQONAkBx3HYnrL3QzFhoR3pwmZHw8ko0dyAx+RAuRki+/6I1CkjFTmQ+hccqtj1LqvX8GWUQ7jnSrq/Lq0/ZNRcDON6BAkA12WqseF4iEuHeOjFN6qNTpBKgE3vrxtU5r696T/cUpda/fjiJghWzssSKTxpOk6j0JM0bEhv9Z1712uMbemyRAkBappIZROfhR1Fpnnt9afDGFML6V8MFxPLOsBB/oVJ+UcY/zNVdhRX+o2a5yae7U4/lSH7mS6hjmLSql6PKc0fo";
//        String sign = RSA.sign(RSA.Mode.SHA256withRSA, sBuilder.toString(), privateKey);
//        String signHeader = String.format("t=%s,v=%s", "1657261165", sign);
//        System.out.println(signHeader);
//
//    }
}
